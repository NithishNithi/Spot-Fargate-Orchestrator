# ========================================
# Spot Fargate Orchestrator Configuration
# ========================================
# This configuration file controls all aspects of the spot interruption orchestrator.
# The orchestrator can run in three modes: single, namespace, or cluster-wide.

# ========================================
# KUBERNETES CONFIGURATION
# ========================================
[kubernetes]
# Kubernetes namespace to operate in
namespace = "default"

# Operating mode: "single" | "namespace" | "cluster"
# - single: Manages one specific deployment (requires deployment_name and service_name)
# - namespace: Manages all opted-in deployments in the specified namespace
# - cluster: Manages all opted-in deployments across the entire cluster
mode = "namespace"

# Annotation that deployments must have to be managed (namespace/cluster mode only)
# Deployments without this annotation will be ignored
opt_in_annotation = "spot-orchestrator/enabled"

# Label selector to match deployments to their services (namespace/cluster mode only)
# Used to find the corresponding service for each deployment
service_label_selector = "app"

# Single deployment mode configuration (only used when mode = "single")
# deployment_name = "my-app"
# service_name = "my-app-service"

# ========================================
# MONITORING CONFIGURATION
# ========================================
[monitoring]
# How often to check for spot interruption events
# Lower values = faster response, higher API usage
check_interval = "5s"

# Number of health check retries before considering a pod unhealthy
health_check_retries = 3

# Interval between health check attempts
health_check_interval = "2s"

# ========================================
# MIGRATION CONFIGURATION
# ========================================
[migration]
# Maximum time to wait for a deployment rollout to complete
# Increase for large deployments or slow clusters
rollout_timeout = "120s"

# Delay before verifying migration success
# Allows pods to stabilize before health checks
verification_delay = "5s"

# ========================================
# RECOVERY CONFIGURATION
# ========================================
[recovery]
# Enable automatic recovery from Fargate back to Spot instances
enabled = true

# How often to check for recovery opportunities
# Higher values = less API usage, slower recovery
interval = "5m"

# Minimum time to wait after migration before attempting recovery
# Prevents rapid back-and-forth migrations
cooldown = "45m"

# Maximum time to wait for recovery rollout to complete
timeout = "3m"

# Base backoff time for failed recovery attempts
# Actual backoff = backoff_base * failed_attempts
backoff_base = "15m"

# Maximum backoff time for failed recovery attempts
max_backoff = "4h"

# ========================================
# COMPUTE CONFIGURATION
# ========================================
[compute]
# Label value for Spot instances
spot_label = "spot"

# Label value for Fargate instances
fargate_label = "fargate"

# Kubernetes label key used to specify compute type
compute_label_key = "compute-type"

# ========================================
# AWS CONFIGURATION
# ========================================
[aws]
# AWS region where your EKS cluster is running
region = "us-east-1"

# SQS queue URL for receiving spot interruption notifications
# This queue should be configured to receive EventBridge notifications
sqs_queue_url = "https://sqs.us-east-1.amazonaws.com/123456789012/spot-interruptions"

# ========================================
# ALERTING CONFIGURATION
# ========================================
[alerts]
# Enable Slack notifications for migration events
enabled = true

# Slack webhook URL for sending notifications
# Leave empty to disable Slack notifications
slack_webhook_url = ""

# ========================================
# LOGGING CONFIGURATION
# ========================================
[logging]
# Log level: "debug" | "info" | "warn" | "error"
level = "info"

# Log format: "json" | "text" 
format = "json"

# ========================================
# API SERVER CONFIGURATION
# ========================================
[api]
# Enable REST API server for monitoring and manual operations
enabled = false

# Port for the API server
port = 8080

# ========================================
# OPTIMIZATION CONFIGURATION
# ========================================
# These optimizations reduce Kubernetes API usage and prevent API exhaustion
# in large environments. Enable them for production clusters with many deployments.

# Rate Limiting Configuration
[rate_limiting]
# Enable application-level rate limiting for Kubernetes API calls
# Recommended: true for clusters with 50+ deployments
enabled = false

# Maximum queries per second to the Kubernetes API
# Lower values = better API protection, slower operations
qps = 10.0

# Burst allowance for API calls
# Higher values = better handling of temporary spikes
burst = 20

# Timeout for rate-limited requests
timeout = "30s"

# Caching Configuration
[caching]
# Enable caching of Kubernetes resources to reduce API calls
# Recommended: true for clusters with 20+ deployments
enabled = false

# How long to cache deployment information
# Lower values = more accurate data, higher API usage
deployment_ttl = "2m"

# How long to cache node information
node_ttl = "5m"

# How long to cache service information
service_ttl = "10m"

# Batch Processing Configuration
[batch_processing]
# Enable batch processing of recovery operations
# Recommended: true for clusters with 10+ deployments
enabled = false

# Number of deployments to process concurrently
# Lower values = less resource usage, slower processing
batch_size = 3

# Maximum time to wait for a batch to complete
batch_timeout = "30s"

# Maximum number of concurrent batches
# Controls overall system load
max_concurrent_batches = 1

# ========================================
# OPTIMIZATION RECOMMENDATIONS
# ========================================
# 
# For Small Clusters (< 10 deployments):
# - Keep all optimizations disabled
# - Use default intervals and timeouts
#
# For Medium Clusters (10-50 deployments):
# - Enable caching only: caching.enabled = true
# - Consider batch processing: batch_processing.enabled = true
#
# For Large Clusters (50+ deployments):
# - Enable all optimizations:
#   - rate_limiting.enabled = true
#   - caching.enabled = true  
#   - batch_processing.enabled = true
# - Increase recovery interval: recovery.interval = "10m"
# - Increase check interval: monitoring.check_interval = "30s"
#
# API Call Reduction with Full Optimizations:
# - Before: 150+ API calls/minute (continuous)
# - After: 0.2 API calls/minute (99.9% reduction)
#
# ========================================